Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> program declaration Semi
Rule 4     program -> empty
Rule 5     type -> Int
Rule 6     function -> type Identifier LParen paramlist RParen LBrace block RBrace
Rule 7     function -> type Identifier LParen paramlist RParen Semi
Rule 8     paramlist -> paramlist Comma type Identifier paramindex
Rule 9     paramlist -> empty
Rule 10    paramlist -> type Identifier paramindex
Rule 11    paramindex -> empty
Rule 12    paramindex -> LBracket RBracket
Rule 13    paramindex -> paramindex LBracket Integer RBracket
Rule 14    paramindex -> LBracket Integer RBracket
Rule 15    block -> block block_item
Rule 16    block -> empty
Rule 17    block_item -> statement
Rule 18    block_item -> declaration Semi
Rule 19    statement -> statement_matched
Rule 20    statement -> statement_unmatched
Rule 21    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 22    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 23    statement_unmatched -> If LParen expression RParen statement
Rule 24    statement_matched -> While LParen expression RParen statement_matched
Rule 25    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 26    statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 27    statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 28    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 29    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 30    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 31    statement_matched -> Return expression Semi
Rule 32    statement_matched -> opt_expression Semi
Rule 33    statement_matched -> LBrace block RBrace
Rule 34    statement_matched -> Break Semi
Rule 35    statement_matched -> Continue Semi
Rule 36    opt_expression -> expression
Rule 37    opt_expression -> empty
Rule 38    declaration -> type Identifier
Rule 39    declaration -> type Identifier arrayindex
Rule 40    declaration -> type Identifier arrayindex arrayInit
Rule 41    arrayInit -> Assign LBrace integerList RBrace
Rule 42    integerList -> integerList Comma Integer
Rule 43    integerList -> Integer
Rule 44    integerList -> empty
Rule 45    declaration -> type Identifier Assign expression
Rule 46    arrayindex -> arrayindex LBracket Integer RBracket
Rule 47    arrayindex -> LBracket Integer RBracket
Rule 48    expression -> assignment
Rule 49    assignment -> conditional
Rule 50    conditional -> logical_or
Rule 51    logical_or -> logical_and
Rule 52    logical_and -> bit_or
Rule 53    bit_or -> xor
Rule 54    xor -> bit_and
Rule 55    bit_and -> equality
Rule 56    equality -> relational
Rule 57    relational -> additive
Rule 58    additive -> multiplicative
Rule 59    multiplicative -> unary
Rule 60    unary -> postfix
Rule 61    postfix -> primary
Rule 62    unary -> Minus unary
Rule 63    unary -> BitNot unary
Rule 64    unary -> Not unary
Rule 65    postfix -> Identifier LParen expression_list RParen
Rule 66    postfix -> postfix LBracket expression RBracket
Rule 67    expression_list -> expression_list Comma expression
Rule 68    expression_list -> empty
Rule 69    expression_list -> expression
Rule 70    assignment -> unary Assign expression
Rule 71    logical_or -> logical_or Or logical_and
Rule 72    logical_and -> logical_and And bit_or
Rule 73    bit_or -> bit_or BitOr xor
Rule 74    xor -> xor Xor bit_and
Rule 75    bit_and -> bit_and BitAnd equality
Rule 76    equality -> equality NotEqual relational
Rule 77    equality -> equality Equal relational
Rule 78    relational -> relational Less additive
Rule 79    relational -> relational Greater additive
Rule 80    relational -> relational LessEqual additive
Rule 81    relational -> relational GreaterEqual additive
Rule 82    additive -> additive Plus multiplicative
Rule 83    additive -> additive Minus multiplicative
Rule 84    multiplicative -> multiplicative Mul unary
Rule 85    multiplicative -> multiplicative Div unary
Rule 86    multiplicative -> multiplicative Mod unary
Rule 87    conditional -> logical_or Question expression Colon conditional
Rule 88    primary -> Integer
Rule 89    primary -> Identifier
Rule 90    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 72
Assign               : 41 45 70
BitAnd               : 75
BitNot               : 63
BitOr                : 73
Break                : 34
Colon                : 87
Comma                : 8 42 67
Continue             : 35
Div                  : 85
Do                   : 30
Else                 : 21 22
Equal                : 77
For                  : 26 27 28 29
Greater              : 79
GreaterEqual         : 81
Identifier           : 6 7 8 10 38 39 40 45 65 89
If                   : 21 22 23
Int                  : 5
Integer              : 13 14 42 43 46 47 88
LBrace               : 6 33 41
LBracket             : 12 13 14 46 47 66
LParen               : 6 7 21 22 23 24 25 26 27 28 29 30 65 90
Less                 : 78
LessEqual            : 80
Minus                : 62 83
Mod                  : 86
Mul                  : 84
Not                  : 64
NotEqual             : 76
Or                   : 71
Plus                 : 82
Question             : 87
RBrace               : 6 33 41
RBracket             : 12 13 14 46 47 66
RParen               : 6 7 21 22 23 24 25 26 27 28 29 30 65 90
Return               : 31
Semi                 : 3 7 18 26 26 27 27 28 28 29 29 30 31 32 34 35
While                : 24 25 30
Xor                  : 74
error                : 

Nonterminals, with rules where they appear

additive             : 57 78 79 80 81 82 83
arrayInit            : 40
arrayindex           : 39 40 46
assignment           : 48
bit_and              : 54 74 75
bit_or               : 52 72 73
block                : 6 15 33
block_item           : 15
conditional          : 49 87
declaration          : 3 18 27 29
empty                : 4 9 11 16 37 44 68
equality             : 55 75 76 77
expression           : 21 22 23 24 25 30 31 36 45 66 67 69 70 87 90
expression_list      : 65 67
function             : 2
integerList          : 41 42
logical_and          : 51 71 72
logical_or           : 50 71 87
multiplicative       : 58 82 83 84 85 86
opt_expression       : 26 26 26 27 27 28 28 28 29 29 32
paramindex           : 8 10 13
paramlist            : 6 7 8
postfix              : 60 66
primary              : 61
program              : 2 3 0
relational           : 56 76 77 78 79 80 81
statement            : 17 23
statement_matched    : 19 21 21 22 24 26 27 30
statement_unmatched  : 20 22 25 28 29
type                 : 6 7 8 10 38 39 40 45
unary                : 59 62 63 64 70 84 85 86
xor                  : 53 73 74

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . program declaration Semi
    (4) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . function
    (3) program -> program . declaration Semi
    (6) function -> . type Identifier LParen paramlist RParen LBrace block RBrace
    (7) function -> . type Identifier LParen paramlist RParen Semi
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier arrayindex
    (40) declaration -> . type Identifier arrayindex arrayInit
    (45) declaration -> . type Identifier Assign expression
    (5) type -> . Int

    Int             shift and go to state 6

    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5

state 2

    (4) program -> empty .

    Int             reduce using rule 4 (program -> empty .)
    $end            reduce using rule 4 (program -> empty .)


state 3

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 4

    (3) program -> program declaration . Semi

    Semi            shift and go to state 7


state 5

    (6) function -> type . Identifier LParen paramlist RParen LBrace block RBrace
    (7) function -> type . Identifier LParen paramlist RParen Semi
    (38) declaration -> type . Identifier
    (39) declaration -> type . Identifier arrayindex
    (40) declaration -> type . Identifier arrayindex arrayInit
    (45) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 8


state 6

    (5) type -> Int .

    Identifier      reduce using rule 5 (type -> Int .)


state 7

    (3) program -> program declaration Semi .

    Int             reduce using rule 3 (program -> program declaration Semi .)
    $end            reduce using rule 3 (program -> program declaration Semi .)


state 8

    (6) function -> type Identifier . LParen paramlist RParen LBrace block RBrace
    (7) function -> type Identifier . LParen paramlist RParen Semi
    (38) declaration -> type Identifier .
    (39) declaration -> type Identifier . arrayindex
    (40) declaration -> type Identifier . arrayindex arrayInit
    (45) declaration -> type Identifier . Assign expression
    (46) arrayindex -> . arrayindex LBracket Integer RBracket
    (47) arrayindex -> . LBracket Integer RBracket

    LParen          shift and go to state 9
    Semi            reduce using rule 38 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 12

    arrayindex                     shift and go to state 10

state 9

    (6) function -> type Identifier LParen . paramlist RParen LBrace block RBrace
    (7) function -> type Identifier LParen . paramlist RParen Semi
    (8) paramlist -> . paramlist Comma type Identifier paramindex
    (9) paramlist -> . empty
    (10) paramlist -> . type Identifier paramindex
    (1) empty -> .
    (5) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 6

    type                           shift and go to state 13
    paramlist                      shift and go to state 14
    empty                          shift and go to state 15

state 10

    (39) declaration -> type Identifier arrayindex .
    (40) declaration -> type Identifier arrayindex . arrayInit
    (46) arrayindex -> arrayindex . LBracket Integer RBracket
    (41) arrayInit -> . Assign LBrace integerList RBrace

    Semi            reduce using rule 39 (declaration -> type Identifier arrayindex .)
    LBracket        shift and go to state 17
    Assign          shift and go to state 18

    arrayInit                      shift and go to state 16

state 11

    (45) declaration -> type Identifier Assign . expression
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 20
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 12

    (47) arrayindex -> LBracket . Integer RBracket

    Integer         shift and go to state 40


state 13

    (10) paramlist -> type . Identifier paramindex

    Identifier      shift and go to state 41


state 14

    (6) function -> type Identifier LParen paramlist . RParen LBrace block RBrace
    (7) function -> type Identifier LParen paramlist . RParen Semi
    (8) paramlist -> paramlist . Comma type Identifier paramindex

    RParen          shift and go to state 42
    Comma           shift and go to state 43


state 15

    (9) paramlist -> empty .

    RParen          reduce using rule 9 (paramlist -> empty .)
    Comma           reduce using rule 9 (paramlist -> empty .)


state 16

    (40) declaration -> type Identifier arrayindex arrayInit .

    Semi            reduce using rule 40 (declaration -> type Identifier arrayindex arrayInit .)


state 17

    (46) arrayindex -> arrayindex LBracket . Integer RBracket

    Integer         shift and go to state 44


state 18

    (41) arrayInit -> Assign . LBrace integerList RBrace

    LBrace          shift and go to state 45


state 19

    (65) postfix -> Identifier . LParen expression_list RParen
    (89) primary -> Identifier .

    LParen          shift and go to state 46
    LBracket        reduce using rule 89 (primary -> Identifier .)
    Assign          reduce using rule 89 (primary -> Identifier .)
    Mul             reduce using rule 89 (primary -> Identifier .)
    Div             reduce using rule 89 (primary -> Identifier .)
    Mod             reduce using rule 89 (primary -> Identifier .)
    Plus            reduce using rule 89 (primary -> Identifier .)
    Minus           reduce using rule 89 (primary -> Identifier .)
    Less            reduce using rule 89 (primary -> Identifier .)
    Greater         reduce using rule 89 (primary -> Identifier .)
    LessEqual       reduce using rule 89 (primary -> Identifier .)
    GreaterEqual    reduce using rule 89 (primary -> Identifier .)
    NotEqual        reduce using rule 89 (primary -> Identifier .)
    Equal           reduce using rule 89 (primary -> Identifier .)
    BitAnd          reduce using rule 89 (primary -> Identifier .)
    Xor             reduce using rule 89 (primary -> Identifier .)
    BitOr           reduce using rule 89 (primary -> Identifier .)
    And             reduce using rule 89 (primary -> Identifier .)
    Question        reduce using rule 89 (primary -> Identifier .)
    Or              reduce using rule 89 (primary -> Identifier .)
    Semi            reduce using rule 89 (primary -> Identifier .)
    RParen          reduce using rule 89 (primary -> Identifier .)
    Comma           reduce using rule 89 (primary -> Identifier .)
    Colon           reduce using rule 89 (primary -> Identifier .)
    RBracket        reduce using rule 89 (primary -> Identifier .)


state 20

    (45) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 45 (declaration -> type Identifier Assign expression .)


state 21

    (48) expression -> assignment .

    Semi            reduce using rule 48 (expression -> assignment .)
    RParen          reduce using rule 48 (expression -> assignment .)
    Comma           reduce using rule 48 (expression -> assignment .)
    Colon           reduce using rule 48 (expression -> assignment .)
    RBracket        reduce using rule 48 (expression -> assignment .)


state 22

    (49) assignment -> conditional .

    Semi            reduce using rule 49 (assignment -> conditional .)
    RParen          reduce using rule 49 (assignment -> conditional .)
    Comma           reduce using rule 49 (assignment -> conditional .)
    Colon           reduce using rule 49 (assignment -> conditional .)
    RBracket        reduce using rule 49 (assignment -> conditional .)


state 23

    (70) assignment -> unary . Assign expression
    (59) multiplicative -> unary .

    Assign          shift and go to state 47
    Mul             reduce using rule 59 (multiplicative -> unary .)
    Div             reduce using rule 59 (multiplicative -> unary .)
    Mod             reduce using rule 59 (multiplicative -> unary .)
    Plus            reduce using rule 59 (multiplicative -> unary .)
    Minus           reduce using rule 59 (multiplicative -> unary .)
    Less            reduce using rule 59 (multiplicative -> unary .)
    Greater         reduce using rule 59 (multiplicative -> unary .)
    LessEqual       reduce using rule 59 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 59 (multiplicative -> unary .)
    NotEqual        reduce using rule 59 (multiplicative -> unary .)
    Equal           reduce using rule 59 (multiplicative -> unary .)
    BitAnd          reduce using rule 59 (multiplicative -> unary .)
    Xor             reduce using rule 59 (multiplicative -> unary .)
    BitOr           reduce using rule 59 (multiplicative -> unary .)
    And             reduce using rule 59 (multiplicative -> unary .)
    Question        reduce using rule 59 (multiplicative -> unary .)
    Or              reduce using rule 59 (multiplicative -> unary .)
    Semi            reduce using rule 59 (multiplicative -> unary .)
    RParen          reduce using rule 59 (multiplicative -> unary .)
    Comma           reduce using rule 59 (multiplicative -> unary .)
    Colon           reduce using rule 59 (multiplicative -> unary .)
    RBracket        reduce using rule 59 (multiplicative -> unary .)


state 24

    (50) conditional -> logical_or .
    (87) conditional -> logical_or . Question expression Colon conditional
    (71) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 50 (conditional -> logical_or .)
    RParen          reduce using rule 50 (conditional -> logical_or .)
    Comma           reduce using rule 50 (conditional -> logical_or .)
    Colon           reduce using rule 50 (conditional -> logical_or .)
    RBracket        reduce using rule 50 (conditional -> logical_or .)
    Question        shift and go to state 48
    Or              shift and go to state 49


state 25

    (60) unary -> postfix .
    (66) postfix -> postfix . LBracket expression RBracket

    Assign          reduce using rule 60 (unary -> postfix .)
    Mul             reduce using rule 60 (unary -> postfix .)
    Div             reduce using rule 60 (unary -> postfix .)
    Mod             reduce using rule 60 (unary -> postfix .)
    Plus            reduce using rule 60 (unary -> postfix .)
    Minus           reduce using rule 60 (unary -> postfix .)
    Less            reduce using rule 60 (unary -> postfix .)
    Greater         reduce using rule 60 (unary -> postfix .)
    LessEqual       reduce using rule 60 (unary -> postfix .)
    GreaterEqual    reduce using rule 60 (unary -> postfix .)
    NotEqual        reduce using rule 60 (unary -> postfix .)
    Equal           reduce using rule 60 (unary -> postfix .)
    BitAnd          reduce using rule 60 (unary -> postfix .)
    Xor             reduce using rule 60 (unary -> postfix .)
    BitOr           reduce using rule 60 (unary -> postfix .)
    And             reduce using rule 60 (unary -> postfix .)
    Question        reduce using rule 60 (unary -> postfix .)
    Or              reduce using rule 60 (unary -> postfix .)
    Semi            reduce using rule 60 (unary -> postfix .)
    RParen          reduce using rule 60 (unary -> postfix .)
    Comma           reduce using rule 60 (unary -> postfix .)
    Colon           reduce using rule 60 (unary -> postfix .)
    RBracket        reduce using rule 60 (unary -> postfix .)
    LBracket        shift and go to state 50


state 26

    (62) unary -> Minus . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 51
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 27

    (63) unary -> BitNot . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 52
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 28

    (64) unary -> Not . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 53
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 29

    (51) logical_or -> logical_and .
    (72) logical_and -> logical_and . And bit_or

    Question        reduce using rule 51 (logical_or -> logical_and .)
    Or              reduce using rule 51 (logical_or -> logical_and .)
    Semi            reduce using rule 51 (logical_or -> logical_and .)
    RParen          reduce using rule 51 (logical_or -> logical_and .)
    Comma           reduce using rule 51 (logical_or -> logical_and .)
    Colon           reduce using rule 51 (logical_or -> logical_and .)
    RBracket        reduce using rule 51 (logical_or -> logical_and .)
    And             shift and go to state 54


state 30

    (61) postfix -> primary .

    LBracket        reduce using rule 61 (postfix -> primary .)
    Assign          reduce using rule 61 (postfix -> primary .)
    Mul             reduce using rule 61 (postfix -> primary .)
    Div             reduce using rule 61 (postfix -> primary .)
    Mod             reduce using rule 61 (postfix -> primary .)
    Plus            reduce using rule 61 (postfix -> primary .)
    Minus           reduce using rule 61 (postfix -> primary .)
    Less            reduce using rule 61 (postfix -> primary .)
    Greater         reduce using rule 61 (postfix -> primary .)
    LessEqual       reduce using rule 61 (postfix -> primary .)
    GreaterEqual    reduce using rule 61 (postfix -> primary .)
    NotEqual        reduce using rule 61 (postfix -> primary .)
    Equal           reduce using rule 61 (postfix -> primary .)
    BitAnd          reduce using rule 61 (postfix -> primary .)
    Xor             reduce using rule 61 (postfix -> primary .)
    BitOr           reduce using rule 61 (postfix -> primary .)
    And             reduce using rule 61 (postfix -> primary .)
    Question        reduce using rule 61 (postfix -> primary .)
    Or              reduce using rule 61 (postfix -> primary .)
    Semi            reduce using rule 61 (postfix -> primary .)
    RParen          reduce using rule 61 (postfix -> primary .)
    Comma           reduce using rule 61 (postfix -> primary .)
    Colon           reduce using rule 61 (postfix -> primary .)
    RBracket        reduce using rule 61 (postfix -> primary .)


state 31

    (90) primary -> LParen . expression RParen
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 55
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 32

    (52) logical_and -> bit_or .
    (73) bit_or -> bit_or . BitOr xor

    And             reduce using rule 52 (logical_and -> bit_or .)
    Question        reduce using rule 52 (logical_and -> bit_or .)
    Or              reduce using rule 52 (logical_and -> bit_or .)
    Semi            reduce using rule 52 (logical_and -> bit_or .)
    RParen          reduce using rule 52 (logical_and -> bit_or .)
    Comma           reduce using rule 52 (logical_and -> bit_or .)
    Colon           reduce using rule 52 (logical_and -> bit_or .)
    RBracket        reduce using rule 52 (logical_and -> bit_or .)
    BitOr           shift and go to state 56


state 33

    (88) primary -> Integer .

    LBracket        reduce using rule 88 (primary -> Integer .)
    Assign          reduce using rule 88 (primary -> Integer .)
    Mul             reduce using rule 88 (primary -> Integer .)
    Div             reduce using rule 88 (primary -> Integer .)
    Mod             reduce using rule 88 (primary -> Integer .)
    Plus            reduce using rule 88 (primary -> Integer .)
    Minus           reduce using rule 88 (primary -> Integer .)
    Less            reduce using rule 88 (primary -> Integer .)
    Greater         reduce using rule 88 (primary -> Integer .)
    LessEqual       reduce using rule 88 (primary -> Integer .)
    GreaterEqual    reduce using rule 88 (primary -> Integer .)
    NotEqual        reduce using rule 88 (primary -> Integer .)
    Equal           reduce using rule 88 (primary -> Integer .)
    BitAnd          reduce using rule 88 (primary -> Integer .)
    Xor             reduce using rule 88 (primary -> Integer .)
    BitOr           reduce using rule 88 (primary -> Integer .)
    And             reduce using rule 88 (primary -> Integer .)
    Question        reduce using rule 88 (primary -> Integer .)
    Or              reduce using rule 88 (primary -> Integer .)
    Semi            reduce using rule 88 (primary -> Integer .)
    RParen          reduce using rule 88 (primary -> Integer .)
    Comma           reduce using rule 88 (primary -> Integer .)
    Colon           reduce using rule 88 (primary -> Integer .)
    RBracket        reduce using rule 88 (primary -> Integer .)


state 34

    (53) bit_or -> xor .
    (74) xor -> xor . Xor bit_and

    BitOr           reduce using rule 53 (bit_or -> xor .)
    And             reduce using rule 53 (bit_or -> xor .)
    Question        reduce using rule 53 (bit_or -> xor .)
    Or              reduce using rule 53 (bit_or -> xor .)
    Semi            reduce using rule 53 (bit_or -> xor .)
    RParen          reduce using rule 53 (bit_or -> xor .)
    Comma           reduce using rule 53 (bit_or -> xor .)
    Colon           reduce using rule 53 (bit_or -> xor .)
    RBracket        reduce using rule 53 (bit_or -> xor .)
    Xor             shift and go to state 57


state 35

    (54) xor -> bit_and .
    (75) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 54 (xor -> bit_and .)
    BitOr           reduce using rule 54 (xor -> bit_and .)
    And             reduce using rule 54 (xor -> bit_and .)
    Question        reduce using rule 54 (xor -> bit_and .)
    Or              reduce using rule 54 (xor -> bit_and .)
    Semi            reduce using rule 54 (xor -> bit_and .)
    RParen          reduce using rule 54 (xor -> bit_and .)
    Comma           reduce using rule 54 (xor -> bit_and .)
    Colon           reduce using rule 54 (xor -> bit_and .)
    RBracket        reduce using rule 54 (xor -> bit_and .)
    BitAnd          shift and go to state 58


state 36

    (55) bit_and -> equality .
    (76) equality -> equality . NotEqual relational
    (77) equality -> equality . Equal relational

    BitAnd          reduce using rule 55 (bit_and -> equality .)
    Xor             reduce using rule 55 (bit_and -> equality .)
    BitOr           reduce using rule 55 (bit_and -> equality .)
    And             reduce using rule 55 (bit_and -> equality .)
    Question        reduce using rule 55 (bit_and -> equality .)
    Or              reduce using rule 55 (bit_and -> equality .)
    Semi            reduce using rule 55 (bit_and -> equality .)
    RParen          reduce using rule 55 (bit_and -> equality .)
    Comma           reduce using rule 55 (bit_and -> equality .)
    Colon           reduce using rule 55 (bit_and -> equality .)
    RBracket        reduce using rule 55 (bit_and -> equality .)
    NotEqual        shift and go to state 59
    Equal           shift and go to state 60


state 37

    (56) equality -> relational .
    (78) relational -> relational . Less additive
    (79) relational -> relational . Greater additive
    (80) relational -> relational . LessEqual additive
    (81) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 56 (equality -> relational .)
    Equal           reduce using rule 56 (equality -> relational .)
    BitAnd          reduce using rule 56 (equality -> relational .)
    Xor             reduce using rule 56 (equality -> relational .)
    BitOr           reduce using rule 56 (equality -> relational .)
    And             reduce using rule 56 (equality -> relational .)
    Question        reduce using rule 56 (equality -> relational .)
    Or              reduce using rule 56 (equality -> relational .)
    Semi            reduce using rule 56 (equality -> relational .)
    RParen          reduce using rule 56 (equality -> relational .)
    Comma           reduce using rule 56 (equality -> relational .)
    Colon           reduce using rule 56 (equality -> relational .)
    RBracket        reduce using rule 56 (equality -> relational .)
    Less            shift and go to state 61
    Greater         shift and go to state 62
    LessEqual       shift and go to state 63
    GreaterEqual    shift and go to state 64


state 38

    (57) relational -> additive .
    (82) additive -> additive . Plus multiplicative
    (83) additive -> additive . Minus multiplicative

    Less            reduce using rule 57 (relational -> additive .)
    Greater         reduce using rule 57 (relational -> additive .)
    LessEqual       reduce using rule 57 (relational -> additive .)
    GreaterEqual    reduce using rule 57 (relational -> additive .)
    NotEqual        reduce using rule 57 (relational -> additive .)
    Equal           reduce using rule 57 (relational -> additive .)
    BitAnd          reduce using rule 57 (relational -> additive .)
    Xor             reduce using rule 57 (relational -> additive .)
    BitOr           reduce using rule 57 (relational -> additive .)
    And             reduce using rule 57 (relational -> additive .)
    Question        reduce using rule 57 (relational -> additive .)
    Or              reduce using rule 57 (relational -> additive .)
    Semi            reduce using rule 57 (relational -> additive .)
    RParen          reduce using rule 57 (relational -> additive .)
    Comma           reduce using rule 57 (relational -> additive .)
    Colon           reduce using rule 57 (relational -> additive .)
    RBracket        reduce using rule 57 (relational -> additive .)
    Plus            shift and go to state 65
    Minus           shift and go to state 66


state 39

    (58) additive -> multiplicative .
    (84) multiplicative -> multiplicative . Mul unary
    (85) multiplicative -> multiplicative . Div unary
    (86) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 58 (additive -> multiplicative .)
    Minus           reduce using rule 58 (additive -> multiplicative .)
    Less            reduce using rule 58 (additive -> multiplicative .)
    Greater         reduce using rule 58 (additive -> multiplicative .)
    LessEqual       reduce using rule 58 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 58 (additive -> multiplicative .)
    NotEqual        reduce using rule 58 (additive -> multiplicative .)
    Equal           reduce using rule 58 (additive -> multiplicative .)
    BitAnd          reduce using rule 58 (additive -> multiplicative .)
    Xor             reduce using rule 58 (additive -> multiplicative .)
    BitOr           reduce using rule 58 (additive -> multiplicative .)
    And             reduce using rule 58 (additive -> multiplicative .)
    Question        reduce using rule 58 (additive -> multiplicative .)
    Or              reduce using rule 58 (additive -> multiplicative .)
    Semi            reduce using rule 58 (additive -> multiplicative .)
    RParen          reduce using rule 58 (additive -> multiplicative .)
    Comma           reduce using rule 58 (additive -> multiplicative .)
    Colon           reduce using rule 58 (additive -> multiplicative .)
    RBracket        reduce using rule 58 (additive -> multiplicative .)
    Mul             shift and go to state 67
    Div             shift and go to state 68
    Mod             shift and go to state 69


state 40

    (47) arrayindex -> LBracket Integer . RBracket

    RBracket        shift and go to state 70


state 41

    (10) paramlist -> type Identifier . paramindex
    (11) paramindex -> . empty
    (12) paramindex -> . LBracket RBracket
    (13) paramindex -> . paramindex LBracket Integer RBracket
    (14) paramindex -> . LBracket Integer RBracket
    (1) empty -> .

  ! shift/reduce conflict for LBracket resolved as shift
    LBracket        shift and go to state 73
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

  ! LBracket        [ reduce using rule 1 (empty -> .) ]

    paramindex                     shift and go to state 71
    empty                          shift and go to state 72

state 42

    (6) function -> type Identifier LParen paramlist RParen . LBrace block RBrace
    (7) function -> type Identifier LParen paramlist RParen . Semi

    LBrace          shift and go to state 74
    Semi            shift and go to state 75


state 43

    (8) paramlist -> paramlist Comma . type Identifier paramindex
    (5) type -> . Int

    Int             shift and go to state 6

    type                           shift and go to state 76

state 44

    (46) arrayindex -> arrayindex LBracket Integer . RBracket

    RBracket        shift and go to state 77


state 45

    (41) arrayInit -> Assign LBrace . integerList RBrace
    (42) integerList -> . integerList Comma Integer
    (43) integerList -> . Integer
    (44) integerList -> . empty
    (1) empty -> .

    Integer         shift and go to state 79
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    integerList                    shift and go to state 78
    empty                          shift and go to state 80

state 46

    (65) postfix -> Identifier LParen . expression_list RParen
    (67) expression_list -> . expression_list Comma expression
    (68) expression_list -> . empty
    (69) expression_list -> . expression
    (1) empty -> .
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression_list                shift and go to state 81
    expression                     shift and go to state 82
    empty                          shift and go to state 83
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 47

    (70) assignment -> unary Assign . expression
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 23
    expression                     shift and go to state 84
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 48

    (87) conditional -> logical_or Question . expression Colon conditional
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    logical_or                     shift and go to state 24
    expression                     shift and go to state 85
    conditional                    shift and go to state 22
    assignment                     shift and go to state 21
    unary                          shift and go to state 23
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 49

    (71) logical_or -> logical_or Or . logical_and
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    logical_and                    shift and go to state 86
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 50

    (66) postfix -> postfix LBracket . expression RBracket
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    postfix                        shift and go to state 25
    expression                     shift and go to state 88
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 51

    (62) unary -> Minus unary .

    Assign          reduce using rule 62 (unary -> Minus unary .)
    Mul             reduce using rule 62 (unary -> Minus unary .)
    Div             reduce using rule 62 (unary -> Minus unary .)
    Mod             reduce using rule 62 (unary -> Minus unary .)
    Plus            reduce using rule 62 (unary -> Minus unary .)
    Minus           reduce using rule 62 (unary -> Minus unary .)
    Less            reduce using rule 62 (unary -> Minus unary .)
    Greater         reduce using rule 62 (unary -> Minus unary .)
    LessEqual       reduce using rule 62 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 62 (unary -> Minus unary .)
    NotEqual        reduce using rule 62 (unary -> Minus unary .)
    Equal           reduce using rule 62 (unary -> Minus unary .)
    BitAnd          reduce using rule 62 (unary -> Minus unary .)
    Xor             reduce using rule 62 (unary -> Minus unary .)
    BitOr           reduce using rule 62 (unary -> Minus unary .)
    And             reduce using rule 62 (unary -> Minus unary .)
    Question        reduce using rule 62 (unary -> Minus unary .)
    Or              reduce using rule 62 (unary -> Minus unary .)
    Semi            reduce using rule 62 (unary -> Minus unary .)
    RParen          reduce using rule 62 (unary -> Minus unary .)
    Comma           reduce using rule 62 (unary -> Minus unary .)
    Colon           reduce using rule 62 (unary -> Minus unary .)
    RBracket        reduce using rule 62 (unary -> Minus unary .)


state 52

    (63) unary -> BitNot unary .

    Assign          reduce using rule 63 (unary -> BitNot unary .)
    Mul             reduce using rule 63 (unary -> BitNot unary .)
    Div             reduce using rule 63 (unary -> BitNot unary .)
    Mod             reduce using rule 63 (unary -> BitNot unary .)
    Plus            reduce using rule 63 (unary -> BitNot unary .)
    Minus           reduce using rule 63 (unary -> BitNot unary .)
    Less            reduce using rule 63 (unary -> BitNot unary .)
    Greater         reduce using rule 63 (unary -> BitNot unary .)
    LessEqual       reduce using rule 63 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 63 (unary -> BitNot unary .)
    NotEqual        reduce using rule 63 (unary -> BitNot unary .)
    Equal           reduce using rule 63 (unary -> BitNot unary .)
    BitAnd          reduce using rule 63 (unary -> BitNot unary .)
    Xor             reduce using rule 63 (unary -> BitNot unary .)
    BitOr           reduce using rule 63 (unary -> BitNot unary .)
    And             reduce using rule 63 (unary -> BitNot unary .)
    Question        reduce using rule 63 (unary -> BitNot unary .)
    Or              reduce using rule 63 (unary -> BitNot unary .)
    Semi            reduce using rule 63 (unary -> BitNot unary .)
    RParen          reduce using rule 63 (unary -> BitNot unary .)
    Comma           reduce using rule 63 (unary -> BitNot unary .)
    Colon           reduce using rule 63 (unary -> BitNot unary .)
    RBracket        reduce using rule 63 (unary -> BitNot unary .)


state 53

    (64) unary -> Not unary .

    Assign          reduce using rule 64 (unary -> Not unary .)
    Mul             reduce using rule 64 (unary -> Not unary .)
    Div             reduce using rule 64 (unary -> Not unary .)
    Mod             reduce using rule 64 (unary -> Not unary .)
    Plus            reduce using rule 64 (unary -> Not unary .)
    Minus           reduce using rule 64 (unary -> Not unary .)
    Less            reduce using rule 64 (unary -> Not unary .)
    Greater         reduce using rule 64 (unary -> Not unary .)
    LessEqual       reduce using rule 64 (unary -> Not unary .)
    GreaterEqual    reduce using rule 64 (unary -> Not unary .)
    NotEqual        reduce using rule 64 (unary -> Not unary .)
    Equal           reduce using rule 64 (unary -> Not unary .)
    BitAnd          reduce using rule 64 (unary -> Not unary .)
    Xor             reduce using rule 64 (unary -> Not unary .)
    BitOr           reduce using rule 64 (unary -> Not unary .)
    And             reduce using rule 64 (unary -> Not unary .)
    Question        reduce using rule 64 (unary -> Not unary .)
    Or              reduce using rule 64 (unary -> Not unary .)
    Semi            reduce using rule 64 (unary -> Not unary .)
    RParen          reduce using rule 64 (unary -> Not unary .)
    Comma           reduce using rule 64 (unary -> Not unary .)
    Colon           reduce using rule 64 (unary -> Not unary .)
    RBracket        reduce using rule 64 (unary -> Not unary .)


state 54

    (72) logical_and -> logical_and And . bit_or
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    bit_or                         shift and go to state 89
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 55

    (90) primary -> LParen expression . RParen

    RParen          shift and go to state 90


state 56

    (73) bit_or -> bit_or BitOr . xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    xor                            shift and go to state 91
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 57

    (74) xor -> xor Xor . bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    bit_and                        shift and go to state 92
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 58

    (75) bit_and -> bit_and BitAnd . equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    equality                       shift and go to state 93
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 59

    (76) equality -> equality NotEqual . relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    relational                     shift and go to state 94
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 60

    (77) equality -> equality Equal . relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    relational                     shift and go to state 95
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 61

    (78) relational -> relational Less . additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    additive                       shift and go to state 96
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 62

    (79) relational -> relational Greater . additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    additive                       shift and go to state 97
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 63

    (80) relational -> relational LessEqual . additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    additive                       shift and go to state 98
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 64

    (81) relational -> relational GreaterEqual . additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    additive                       shift and go to state 99
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 65

    (82) additive -> additive Plus . multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    multiplicative                 shift and go to state 100
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 66

    (83) additive -> additive Minus . multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    multiplicative                 shift and go to state 101
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 67

    (84) multiplicative -> multiplicative Mul . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 102
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 68

    (85) multiplicative -> multiplicative Div . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 103
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 69

    (86) multiplicative -> multiplicative Mod . unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    unary                          shift and go to state 104
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 70

    (47) arrayindex -> LBracket Integer RBracket .

    LBracket        reduce using rule 47 (arrayindex -> LBracket Integer RBracket .)
    Assign          reduce using rule 47 (arrayindex -> LBracket Integer RBracket .)
    Semi            reduce using rule 47 (arrayindex -> LBracket Integer RBracket .)


state 71

    (10) paramlist -> type Identifier paramindex .
    (13) paramindex -> paramindex . LBracket Integer RBracket

    RParen          reduce using rule 10 (paramlist -> type Identifier paramindex .)
    Comma           reduce using rule 10 (paramlist -> type Identifier paramindex .)
    LBracket        shift and go to state 105


state 72

    (11) paramindex -> empty .

    LBracket        reduce using rule 11 (paramindex -> empty .)
    RParen          reduce using rule 11 (paramindex -> empty .)
    Comma           reduce using rule 11 (paramindex -> empty .)


state 73

    (12) paramindex -> LBracket . RBracket
    (14) paramindex -> LBracket . Integer RBracket

    RBracket        shift and go to state 106
    Integer         shift and go to state 107


state 74

    (6) function -> type Identifier LParen paramlist RParen LBrace . block RBrace
    (15) block -> . block block_item
    (16) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 108
    empty                          shift and go to state 109

state 75

    (7) function -> type Identifier LParen paramlist RParen Semi .

    Int             reduce using rule 7 (function -> type Identifier LParen paramlist RParen Semi .)
    $end            reduce using rule 7 (function -> type Identifier LParen paramlist RParen Semi .)


state 76

    (8) paramlist -> paramlist Comma type . Identifier paramindex

    Identifier      shift and go to state 110


state 77

    (46) arrayindex -> arrayindex LBracket Integer RBracket .

    LBracket        reduce using rule 46 (arrayindex -> arrayindex LBracket Integer RBracket .)
    Assign          reduce using rule 46 (arrayindex -> arrayindex LBracket Integer RBracket .)
    Semi            reduce using rule 46 (arrayindex -> arrayindex LBracket Integer RBracket .)


state 78

    (41) arrayInit -> Assign LBrace integerList . RBrace
    (42) integerList -> integerList . Comma Integer

    RBrace          shift and go to state 111
    Comma           shift and go to state 112


state 79

    (43) integerList -> Integer .

    RBrace          reduce using rule 43 (integerList -> Integer .)
    Comma           reduce using rule 43 (integerList -> Integer .)


state 80

    (44) integerList -> empty .

    RBrace          reduce using rule 44 (integerList -> empty .)
    Comma           reduce using rule 44 (integerList -> empty .)


state 81

    (65) postfix -> Identifier LParen expression_list . RParen
    (67) expression_list -> expression_list . Comma expression

    RParen          shift and go to state 113
    Comma           shift and go to state 114


state 82

    (69) expression_list -> expression .

    RParen          reduce using rule 69 (expression_list -> expression .)
    Comma           reduce using rule 69 (expression_list -> expression .)


state 83

    (68) expression_list -> empty .

    RParen          reduce using rule 68 (expression_list -> empty .)
    Comma           reduce using rule 68 (expression_list -> empty .)


state 84

    (70) assignment -> unary Assign expression .

    Semi            reduce using rule 70 (assignment -> unary Assign expression .)
    RParen          reduce using rule 70 (assignment -> unary Assign expression .)
    Comma           reduce using rule 70 (assignment -> unary Assign expression .)
    Colon           reduce using rule 70 (assignment -> unary Assign expression .)
    RBracket        reduce using rule 70 (assignment -> unary Assign expression .)


state 85

    (87) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 115


state 86

    (71) logical_or -> logical_or Or logical_and .
    (72) logical_and -> logical_and . And bit_or

    Question        reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 71 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 54


state 87

    (59) multiplicative -> unary .

    Mul             reduce using rule 59 (multiplicative -> unary .)
    Div             reduce using rule 59 (multiplicative -> unary .)
    Mod             reduce using rule 59 (multiplicative -> unary .)
    Plus            reduce using rule 59 (multiplicative -> unary .)
    Minus           reduce using rule 59 (multiplicative -> unary .)
    Less            reduce using rule 59 (multiplicative -> unary .)
    Greater         reduce using rule 59 (multiplicative -> unary .)
    LessEqual       reduce using rule 59 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 59 (multiplicative -> unary .)
    NotEqual        reduce using rule 59 (multiplicative -> unary .)
    Equal           reduce using rule 59 (multiplicative -> unary .)
    BitAnd          reduce using rule 59 (multiplicative -> unary .)
    Xor             reduce using rule 59 (multiplicative -> unary .)
    BitOr           reduce using rule 59 (multiplicative -> unary .)
    And             reduce using rule 59 (multiplicative -> unary .)
    Question        reduce using rule 59 (multiplicative -> unary .)
    Or              reduce using rule 59 (multiplicative -> unary .)
    Semi            reduce using rule 59 (multiplicative -> unary .)
    RParen          reduce using rule 59 (multiplicative -> unary .)
    Comma           reduce using rule 59 (multiplicative -> unary .)
    Colon           reduce using rule 59 (multiplicative -> unary .)
    RBracket        reduce using rule 59 (multiplicative -> unary .)


state 88

    (66) postfix -> postfix LBracket expression . RBracket

    RBracket        shift and go to state 116


state 89

    (72) logical_and -> logical_and And bit_or .
    (73) bit_or -> bit_or . BitOr xor

    And             reduce using rule 72 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 72 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 72 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 72 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 72 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 72 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 72 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 72 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 56


state 90

    (90) primary -> LParen expression RParen .

    LBracket        reduce using rule 90 (primary -> LParen expression RParen .)
    Assign          reduce using rule 90 (primary -> LParen expression RParen .)
    Mul             reduce using rule 90 (primary -> LParen expression RParen .)
    Div             reduce using rule 90 (primary -> LParen expression RParen .)
    Mod             reduce using rule 90 (primary -> LParen expression RParen .)
    Plus            reduce using rule 90 (primary -> LParen expression RParen .)
    Minus           reduce using rule 90 (primary -> LParen expression RParen .)
    Less            reduce using rule 90 (primary -> LParen expression RParen .)
    Greater         reduce using rule 90 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 90 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 90 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 90 (primary -> LParen expression RParen .)
    Equal           reduce using rule 90 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 90 (primary -> LParen expression RParen .)
    Xor             reduce using rule 90 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 90 (primary -> LParen expression RParen .)
    And             reduce using rule 90 (primary -> LParen expression RParen .)
    Question        reduce using rule 90 (primary -> LParen expression RParen .)
    Or              reduce using rule 90 (primary -> LParen expression RParen .)
    Semi            reduce using rule 90 (primary -> LParen expression RParen .)
    RParen          reduce using rule 90 (primary -> LParen expression RParen .)
    Comma           reduce using rule 90 (primary -> LParen expression RParen .)
    Colon           reduce using rule 90 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 90 (primary -> LParen expression RParen .)


state 91

    (73) bit_or -> bit_or BitOr xor .
    (74) xor -> xor . Xor bit_and

    BitOr           reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 73 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 57


state 92

    (74) xor -> xor Xor bit_and .
    (75) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 74 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 74 (xor -> xor Xor bit_and .)
    And             reduce using rule 74 (xor -> xor Xor bit_and .)
    Question        reduce using rule 74 (xor -> xor Xor bit_and .)
    Or              reduce using rule 74 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 74 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 74 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 74 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 74 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 74 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 58


state 93

    (75) bit_and -> bit_and BitAnd equality .
    (76) equality -> equality . NotEqual relational
    (77) equality -> equality . Equal relational

    BitAnd          reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 75 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 59
    Equal           shift and go to state 60


state 94

    (76) equality -> equality NotEqual relational .
    (78) relational -> relational . Less additive
    (79) relational -> relational . Greater additive
    (80) relational -> relational . LessEqual additive
    (81) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 76 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 76 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 76 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 76 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 76 (equality -> equality NotEqual relational .)
    And             reduce using rule 76 (equality -> equality NotEqual relational .)
    Question        reduce using rule 76 (equality -> equality NotEqual relational .)
    Or              reduce using rule 76 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 76 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 76 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 76 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 76 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 76 (equality -> equality NotEqual relational .)
    Less            shift and go to state 61
    Greater         shift and go to state 62
    LessEqual       shift and go to state 63
    GreaterEqual    shift and go to state 64


state 95

    (77) equality -> equality Equal relational .
    (78) relational -> relational . Less additive
    (79) relational -> relational . Greater additive
    (80) relational -> relational . LessEqual additive
    (81) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 77 (equality -> equality Equal relational .)
    Equal           reduce using rule 77 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 77 (equality -> equality Equal relational .)
    Xor             reduce using rule 77 (equality -> equality Equal relational .)
    BitOr           reduce using rule 77 (equality -> equality Equal relational .)
    And             reduce using rule 77 (equality -> equality Equal relational .)
    Question        reduce using rule 77 (equality -> equality Equal relational .)
    Or              reduce using rule 77 (equality -> equality Equal relational .)
    Semi            reduce using rule 77 (equality -> equality Equal relational .)
    RParen          reduce using rule 77 (equality -> equality Equal relational .)
    Comma           reduce using rule 77 (equality -> equality Equal relational .)
    Colon           reduce using rule 77 (equality -> equality Equal relational .)
    RBracket        reduce using rule 77 (equality -> equality Equal relational .)
    Less            shift and go to state 61
    Greater         shift and go to state 62
    LessEqual       shift and go to state 63
    GreaterEqual    shift and go to state 64


state 96

    (78) relational -> relational Less additive .
    (82) additive -> additive . Plus multiplicative
    (83) additive -> additive . Minus multiplicative

    Less            reduce using rule 78 (relational -> relational Less additive .)
    Greater         reduce using rule 78 (relational -> relational Less additive .)
    LessEqual       reduce using rule 78 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 78 (relational -> relational Less additive .)
    NotEqual        reduce using rule 78 (relational -> relational Less additive .)
    Equal           reduce using rule 78 (relational -> relational Less additive .)
    BitAnd          reduce using rule 78 (relational -> relational Less additive .)
    Xor             reduce using rule 78 (relational -> relational Less additive .)
    BitOr           reduce using rule 78 (relational -> relational Less additive .)
    And             reduce using rule 78 (relational -> relational Less additive .)
    Question        reduce using rule 78 (relational -> relational Less additive .)
    Or              reduce using rule 78 (relational -> relational Less additive .)
    Semi            reduce using rule 78 (relational -> relational Less additive .)
    RParen          reduce using rule 78 (relational -> relational Less additive .)
    Comma           reduce using rule 78 (relational -> relational Less additive .)
    Colon           reduce using rule 78 (relational -> relational Less additive .)
    RBracket        reduce using rule 78 (relational -> relational Less additive .)
    Plus            shift and go to state 65
    Minus           shift and go to state 66


state 97

    (79) relational -> relational Greater additive .
    (82) additive -> additive . Plus multiplicative
    (83) additive -> additive . Minus multiplicative

    Less            reduce using rule 79 (relational -> relational Greater additive .)
    Greater         reduce using rule 79 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 79 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 79 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 79 (relational -> relational Greater additive .)
    Equal           reduce using rule 79 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 79 (relational -> relational Greater additive .)
    Xor             reduce using rule 79 (relational -> relational Greater additive .)
    BitOr           reduce using rule 79 (relational -> relational Greater additive .)
    And             reduce using rule 79 (relational -> relational Greater additive .)
    Question        reduce using rule 79 (relational -> relational Greater additive .)
    Or              reduce using rule 79 (relational -> relational Greater additive .)
    Semi            reduce using rule 79 (relational -> relational Greater additive .)
    RParen          reduce using rule 79 (relational -> relational Greater additive .)
    Comma           reduce using rule 79 (relational -> relational Greater additive .)
    Colon           reduce using rule 79 (relational -> relational Greater additive .)
    RBracket        reduce using rule 79 (relational -> relational Greater additive .)
    Plus            shift and go to state 65
    Minus           shift and go to state 66


state 98

    (80) relational -> relational LessEqual additive .
    (82) additive -> additive . Plus multiplicative
    (83) additive -> additive . Minus multiplicative

    Less            reduce using rule 80 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 80 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 80 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 80 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 80 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 80 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 80 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 80 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 80 (relational -> relational LessEqual additive .)
    And             reduce using rule 80 (relational -> relational LessEqual additive .)
    Question        reduce using rule 80 (relational -> relational LessEqual additive .)
    Or              reduce using rule 80 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 80 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 80 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 80 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 80 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 80 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 65
    Minus           shift and go to state 66


state 99

    (81) relational -> relational GreaterEqual additive .
    (82) additive -> additive . Plus multiplicative
    (83) additive -> additive . Minus multiplicative

    Less            reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 81 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 81 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 81 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 81 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 81 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 81 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 81 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 81 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 81 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 65
    Minus           shift and go to state 66


state 100

    (82) additive -> additive Plus multiplicative .
    (84) multiplicative -> multiplicative . Mul unary
    (85) multiplicative -> multiplicative . Div unary
    (86) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 82 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 82 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 82 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 82 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 82 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 82 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 82 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 82 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 82 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 82 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 82 (additive -> additive Plus multiplicative .)
    And             reduce using rule 82 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 82 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 82 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 82 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 82 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 82 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 82 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 82 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 67
    Div             shift and go to state 68
    Mod             shift and go to state 69


state 101

    (83) additive -> additive Minus multiplicative .
    (84) multiplicative -> multiplicative . Mul unary
    (85) multiplicative -> multiplicative . Div unary
    (86) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 83 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 83 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 83 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 83 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 83 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 83 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 83 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 83 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 83 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 83 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 83 (additive -> additive Minus multiplicative .)
    And             reduce using rule 83 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 83 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 83 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 83 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 83 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 83 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 83 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 83 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 67
    Div             shift and go to state 68
    Mod             shift and go to state 69


state 102

    (84) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 84 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 84 (multiplicative -> multiplicative Mul unary .)


state 103

    (85) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 85 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 85 (multiplicative -> multiplicative Div unary .)


state 104

    (86) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 86 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 86 (multiplicative -> multiplicative Mod unary .)


state 105

    (13) paramindex -> paramindex LBracket . Integer RBracket

    Integer         shift and go to state 117


state 106

    (12) paramindex -> LBracket RBracket .

    LBracket        reduce using rule 12 (paramindex -> LBracket RBracket .)
    RParen          reduce using rule 12 (paramindex -> LBracket RBracket .)
    Comma           reduce using rule 12 (paramindex -> LBracket RBracket .)


state 107

    (14) paramindex -> LBracket Integer . RBracket

    RBracket        shift and go to state 118


state 108

    (6) function -> type Identifier LParen paramlist RParen LBrace block . RBrace
    (15) block -> block . block_item
    (17) block_item -> . statement
    (18) block_item -> . declaration Semi
    (19) statement -> . statement_matched
    (20) statement -> . statement_unmatched
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier arrayindex
    (40) declaration -> . type Identifier arrayindex arrayInit
    (45) declaration -> . type Identifier Assign expression
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (5) type -> . Int
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 121
    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    type                           shift and go to state 119
    block_item                     shift and go to state 122
    statement                      shift and go to state 123
    declaration                    shift and go to state 124
    statement_matched              shift and go to state 125
    statement_unmatched            shift and go to state 126
    expression                     shift and go to state 127
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 109

    (16) block -> empty .

    RBrace          reduce using rule 16 (block -> empty .)
    If              reduce using rule 16 (block -> empty .)
    While           reduce using rule 16 (block -> empty .)
    For             reduce using rule 16 (block -> empty .)
    Do              reduce using rule 16 (block -> empty .)
    Return          reduce using rule 16 (block -> empty .)
    LBrace          reduce using rule 16 (block -> empty .)
    Break           reduce using rule 16 (block -> empty .)
    Continue        reduce using rule 16 (block -> empty .)
    Int             reduce using rule 16 (block -> empty .)
    Minus           reduce using rule 16 (block -> empty .)
    BitNot          reduce using rule 16 (block -> empty .)
    Not             reduce using rule 16 (block -> empty .)
    Identifier      reduce using rule 16 (block -> empty .)
    Integer         reduce using rule 16 (block -> empty .)
    LParen          reduce using rule 16 (block -> empty .)
    Semi            reduce using rule 16 (block -> empty .)


state 110

    (8) paramlist -> paramlist Comma type Identifier . paramindex
    (11) paramindex -> . empty
    (12) paramindex -> . LBracket RBracket
    (13) paramindex -> . paramindex LBracket Integer RBracket
    (14) paramindex -> . LBracket Integer RBracket
    (1) empty -> .

  ! shift/reduce conflict for LBracket resolved as shift
    LBracket        shift and go to state 73
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

  ! LBracket        [ reduce using rule 1 (empty -> .) ]

    paramindex                     shift and go to state 137
    empty                          shift and go to state 72

state 111

    (41) arrayInit -> Assign LBrace integerList RBrace .

    Semi            reduce using rule 41 (arrayInit -> Assign LBrace integerList RBrace .)


state 112

    (42) integerList -> integerList Comma . Integer

    Integer         shift and go to state 138


state 113

    (65) postfix -> Identifier LParen expression_list RParen .

    LBracket        reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Assign          reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Mul             reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)
    RBracket        reduce using rule 65 (postfix -> Identifier LParen expression_list RParen .)


state 114

    (67) expression_list -> expression_list Comma . expression
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 139
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 115

    (87) conditional -> logical_or Question expression Colon . conditional
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    logical_or                     shift and go to state 24
    conditional                    shift and go to state 140
    logical_and                    shift and go to state 29
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
    unary                          shift and go to state 87
    postfix                        shift and go to state 25
    primary                        shift and go to state 30

state 116

    (66) postfix -> postfix LBracket expression RBracket .

    LBracket        reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Assign          reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Mul             reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Div             reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Mod             reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Plus            reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Minus           reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Less            reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Greater         reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    LessEqual       reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    GreaterEqual    reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    NotEqual        reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Equal           reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    BitAnd          reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Xor             reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    BitOr           reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    And             reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Question        reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Or              reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Semi            reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    RParen          reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Comma           reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    Colon           reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)
    RBracket        reduce using rule 66 (postfix -> postfix LBracket expression RBracket .)


state 117

    (13) paramindex -> paramindex LBracket Integer . RBracket

    RBracket        shift and go to state 141


state 118

    (14) paramindex -> LBracket Integer RBracket .

    LBracket        reduce using rule 14 (paramindex -> LBracket Integer RBracket .)
    RParen          reduce using rule 14 (paramindex -> LBracket Integer RBracket .)
    Comma           reduce using rule 14 (paramindex -> LBracket Integer RBracket .)


state 119

    (38) declaration -> type . Identifier
    (39) declaration -> type . Identifier arrayindex
    (40) declaration -> type . Identifier arrayindex arrayInit
    (45) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 142


state 120

    (33) statement_matched -> LBrace . block RBrace
    (15) block -> . block block_item
    (16) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 143
    empty                          shift and go to state 109

state 121

    (6) function -> type Identifier LParen paramlist RParen LBrace block RBrace .

    Int             reduce using rule 6 (function -> type Identifier LParen paramlist RParen LBrace block RBrace .)
    $end            reduce using rule 6 (function -> type Identifier LParen paramlist RParen LBrace block RBrace .)


state 122

    (15) block -> block block_item .

    RBrace          reduce using rule 15 (block -> block block_item .)
    If              reduce using rule 15 (block -> block block_item .)
    While           reduce using rule 15 (block -> block block_item .)
    For             reduce using rule 15 (block -> block block_item .)
    Do              reduce using rule 15 (block -> block block_item .)
    Return          reduce using rule 15 (block -> block block_item .)
    LBrace          reduce using rule 15 (block -> block block_item .)
    Break           reduce using rule 15 (block -> block block_item .)
    Continue        reduce using rule 15 (block -> block block_item .)
    Int             reduce using rule 15 (block -> block block_item .)
    Minus           reduce using rule 15 (block -> block block_item .)
    BitNot          reduce using rule 15 (block -> block block_item .)
    Not             reduce using rule 15 (block -> block block_item .)
    Identifier      reduce using rule 15 (block -> block block_item .)
    Integer         reduce using rule 15 (block -> block block_item .)
    LParen          reduce using rule 15 (block -> block block_item .)
    Semi            reduce using rule 15 (block -> block block_item .)


state 123

    (17) block_item -> statement .

    RBrace          reduce using rule 17 (block_item -> statement .)
    If              reduce using rule 17 (block_item -> statement .)
    While           reduce using rule 17 (block_item -> statement .)
    For             reduce using rule 17 (block_item -> statement .)
    Do              reduce using rule 17 (block_item -> statement .)
    Return          reduce using rule 17 (block_item -> statement .)
    LBrace          reduce using rule 17 (block_item -> statement .)
    Break           reduce using rule 17 (block_item -> statement .)
    Continue        reduce using rule 17 (block_item -> statement .)
    Int             reduce using rule 17 (block_item -> statement .)
    Minus           reduce using rule 17 (block_item -> statement .)
    BitNot          reduce using rule 17 (block_item -> statement .)
    Not             reduce using rule 17 (block_item -> statement .)
    Identifier      reduce using rule 17 (block_item -> statement .)
    Integer         reduce using rule 17 (block_item -> statement .)
    LParen          reduce using rule 17 (block_item -> statement .)
    Semi            reduce using rule 17 (block_item -> statement .)


state 124

    (18) block_item -> declaration . Semi

    Semi            shift and go to state 144


state 125

    (19) statement -> statement_matched .

    RBrace          reduce using rule 19 (statement -> statement_matched .)
    If              reduce using rule 19 (statement -> statement_matched .)
    While           reduce using rule 19 (statement -> statement_matched .)
    For             reduce using rule 19 (statement -> statement_matched .)
    Do              reduce using rule 19 (statement -> statement_matched .)
    Return          reduce using rule 19 (statement -> statement_matched .)
    LBrace          reduce using rule 19 (statement -> statement_matched .)
    Break           reduce using rule 19 (statement -> statement_matched .)
    Continue        reduce using rule 19 (statement -> statement_matched .)
    Int             reduce using rule 19 (statement -> statement_matched .)
    Minus           reduce using rule 19 (statement -> statement_matched .)
    BitNot          reduce using rule 19 (statement -> statement_matched .)
    Not             reduce using rule 19 (statement -> statement_matched .)
    Identifier      reduce using rule 19 (statement -> statement_matched .)
    Integer         reduce using rule 19 (statement -> statement_matched .)
    LParen          reduce using rule 19 (statement -> statement_matched .)
    Semi            reduce using rule 19 (statement -> statement_matched .)


state 126

    (20) statement -> statement_unmatched .

    RBrace          reduce using rule 20 (statement -> statement_unmatched .)
    If              reduce using rule 20 (statement -> statement_unmatched .)
    While           reduce using rule 20 (statement -> statement_unmatched .)
    For             reduce using rule 20 (statement -> statement_unmatched .)
    Do              reduce using rule 20 (statement -> statement_unmatched .)
    Return          reduce using rule 20 (statement -> statement_unmatched .)
    LBrace          reduce using rule 20 (statement -> statement_unmatched .)
    Break           reduce using rule 20 (statement -> statement_unmatched .)
    Continue        reduce using rule 20 (statement -> statement_unmatched .)
    Int             reduce using rule 20 (statement -> statement_unmatched .)
    Minus           reduce using rule 20 (statement -> statement_unmatched .)
    BitNot          reduce using rule 20 (statement -> statement_unmatched .)
    Not             reduce using rule 20 (statement -> statement_unmatched .)
    Identifier      reduce using rule 20 (statement -> statement_unmatched .)
    Integer         reduce using rule 20 (statement -> statement_unmatched .)
    LParen          reduce using rule 20 (statement -> statement_unmatched .)
    Semi            reduce using rule 20 (statement -> statement_unmatched .)


state 127

    (36) opt_expression -> expression .

    Semi            reduce using rule 36 (opt_expression -> expression .)
    RParen          reduce using rule 36 (opt_expression -> expression .)


state 128

    (21) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (22) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 145


state 129

    (24) statement_matched -> While . LParen expression RParen statement_matched
    (25) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 146


state 130

    (26) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 147


state 131

    (32) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 148


state 132

    (30) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    statement_matched              shift and go to state 149
    expression                     shift and go to state 127
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 133

    (31) statement_matched -> Return . expression Semi
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 153
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 134

    (34) statement_matched -> Break . Semi

    Semi            shift and go to state 154


state 135

    (35) statement_matched -> Continue . Semi

    Semi            shift and go to state 155


state 136

    (37) opt_expression -> empty .

    Semi            reduce using rule 37 (opt_expression -> empty .)
    RParen          reduce using rule 37 (opt_expression -> empty .)


state 137

    (8) paramlist -> paramlist Comma type Identifier paramindex .
    (13) paramindex -> paramindex . LBracket Integer RBracket

    RParen          reduce using rule 8 (paramlist -> paramlist Comma type Identifier paramindex .)
    Comma           reduce using rule 8 (paramlist -> paramlist Comma type Identifier paramindex .)
    LBracket        shift and go to state 105


state 138

    (42) integerList -> integerList Comma Integer .

    RBrace          reduce using rule 42 (integerList -> integerList Comma Integer .)
    Comma           reduce using rule 42 (integerList -> integerList Comma Integer .)


state 139

    (67) expression_list -> expression_list Comma expression .

    RParen          reduce using rule 67 (expression_list -> expression_list Comma expression .)
    Comma           reduce using rule 67 (expression_list -> expression_list Comma expression .)


state 140

    (87) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 87 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 87 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 87 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 87 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 87 (conditional -> logical_or Question expression Colon conditional .)


state 141

    (13) paramindex -> paramindex LBracket Integer RBracket .

    LBracket        reduce using rule 13 (paramindex -> paramindex LBracket Integer RBracket .)
    RParen          reduce using rule 13 (paramindex -> paramindex LBracket Integer RBracket .)
    Comma           reduce using rule 13 (paramindex -> paramindex LBracket Integer RBracket .)


state 142

    (38) declaration -> type Identifier .
    (39) declaration -> type Identifier . arrayindex
    (40) declaration -> type Identifier . arrayindex arrayInit
    (45) declaration -> type Identifier . Assign expression
    (46) arrayindex -> . arrayindex LBracket Integer RBracket
    (47) arrayindex -> . LBracket Integer RBracket

    Semi            reduce using rule 38 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 12

    arrayindex                     shift and go to state 10

state 143

    (33) statement_matched -> LBrace block . RBrace
    (15) block -> block . block_item
    (17) block_item -> . statement
    (18) block_item -> . declaration Semi
    (19) statement -> . statement_matched
    (20) statement -> . statement_unmatched
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier arrayindex
    (40) declaration -> . type Identifier arrayindex arrayInit
    (45) declaration -> . type Identifier Assign expression
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (5) type -> . Int
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RBrace          shift and go to state 156
    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    block_item                     shift and go to state 122
    statement                      shift and go to state 123
    declaration                    shift and go to state 124
    statement_matched              shift and go to state 125
    statement_unmatched            shift and go to state 126
    type                           shift and go to state 119
    expression                     shift and go to state 127
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 144

    (18) block_item -> declaration Semi .

    RBrace          reduce using rule 18 (block_item -> declaration Semi .)
    If              reduce using rule 18 (block_item -> declaration Semi .)
    While           reduce using rule 18 (block_item -> declaration Semi .)
    For             reduce using rule 18 (block_item -> declaration Semi .)
    Do              reduce using rule 18 (block_item -> declaration Semi .)
    Return          reduce using rule 18 (block_item -> declaration Semi .)
    LBrace          reduce using rule 18 (block_item -> declaration Semi .)
    Break           reduce using rule 18 (block_item -> declaration Semi .)
    Continue        reduce using rule 18 (block_item -> declaration Semi .)
    Int             reduce using rule 18 (block_item -> declaration Semi .)
    Minus           reduce using rule 18 (block_item -> declaration Semi .)
    BitNot          reduce using rule 18 (block_item -> declaration Semi .)
    Not             reduce using rule 18 (block_item -> declaration Semi .)
    Identifier      reduce using rule 18 (block_item -> declaration Semi .)
    Integer         reduce using rule 18 (block_item -> declaration Semi .)
    LParen          reduce using rule 18 (block_item -> declaration Semi .)
    Semi            reduce using rule 18 (block_item -> declaration Semi .)


state 145

    (21) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (22) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> If LParen . expression RParen statement
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 157
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 146

    (24) statement_matched -> While LParen . expression RParen statement_matched
    (25) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 158
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 147

    (26) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier arrayindex
    (40) declaration -> . type Identifier arrayindex arrayInit
    (45) declaration -> . type Identifier Assign expression
    (48) expression -> . assignment
    (1) empty -> .
    (5) type -> . Int
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 6
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 159
    declaration                    shift and go to state 160
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    type                           shift and go to state 119
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 148

    (32) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 32 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 32 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 32 (statement_matched -> opt_expression Semi .)


state 149

    (30) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 161


state 150

    (24) statement_matched -> While . LParen expression RParen statement_matched

    LParen          shift and go to state 162


state 151

    (21) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched

    LParen          shift and go to state 163


state 152

    (26) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched

    LParen          shift and go to state 164


state 153

    (31) statement_matched -> Return expression . Semi

    Semi            shift and go to state 165


state 154

    (34) statement_matched -> Break Semi .

    RBrace          reduce using rule 34 (statement_matched -> Break Semi .)
    If              reduce using rule 34 (statement_matched -> Break Semi .)
    While           reduce using rule 34 (statement_matched -> Break Semi .)
    For             reduce using rule 34 (statement_matched -> Break Semi .)
    Do              reduce using rule 34 (statement_matched -> Break Semi .)
    Return          reduce using rule 34 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 34 (statement_matched -> Break Semi .)
    Break           reduce using rule 34 (statement_matched -> Break Semi .)
    Continue        reduce using rule 34 (statement_matched -> Break Semi .)
    Int             reduce using rule 34 (statement_matched -> Break Semi .)
    Minus           reduce using rule 34 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 34 (statement_matched -> Break Semi .)
    Not             reduce using rule 34 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 34 (statement_matched -> Break Semi .)
    Integer         reduce using rule 34 (statement_matched -> Break Semi .)
    LParen          reduce using rule 34 (statement_matched -> Break Semi .)
    Semi            reduce using rule 34 (statement_matched -> Break Semi .)
    Else            reduce using rule 34 (statement_matched -> Break Semi .)


state 155

    (35) statement_matched -> Continue Semi .

    RBrace          reduce using rule 35 (statement_matched -> Continue Semi .)
    If              reduce using rule 35 (statement_matched -> Continue Semi .)
    While           reduce using rule 35 (statement_matched -> Continue Semi .)
    For             reduce using rule 35 (statement_matched -> Continue Semi .)
    Do              reduce using rule 35 (statement_matched -> Continue Semi .)
    Return          reduce using rule 35 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 35 (statement_matched -> Continue Semi .)
    Break           reduce using rule 35 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 35 (statement_matched -> Continue Semi .)
    Int             reduce using rule 35 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 35 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 35 (statement_matched -> Continue Semi .)
    Not             reduce using rule 35 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 35 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 35 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 35 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 35 (statement_matched -> Continue Semi .)
    Else            reduce using rule 35 (statement_matched -> Continue Semi .)


state 156

    (33) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 33 (statement_matched -> LBrace block RBrace .)


state 157

    (21) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (22) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 166


state 158

    (24) statement_matched -> While LParen expression . RParen statement_matched
    (25) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 167


state 159

    (26) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 168


state 160

    (27) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 169


state 161

    (30) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 170


state 162

    (24) statement_matched -> While LParen . expression RParen statement_matched
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 171
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 163

    (21) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 172
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 164

    (26) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier arrayindex
    (40) declaration -> . type Identifier arrayindex arrayInit
    (45) declaration -> . type Identifier Assign expression
    (48) expression -> . assignment
    (1) empty -> .
    (5) type -> . Int
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 6
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 173
    declaration                    shift and go to state 174
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    type                           shift and go to state 119
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 165

    (31) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 31 (statement_matched -> Return expression Semi .)
    If              reduce using rule 31 (statement_matched -> Return expression Semi .)
    While           reduce using rule 31 (statement_matched -> Return expression Semi .)
    For             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 31 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 31 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 31 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 31 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 31 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 31 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 31 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 31 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 31 (statement_matched -> Return expression Semi .)


state 166

    (21) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (22) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (23) statement_unmatched -> If LParen expression RParen . statement
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (19) statement -> . statement_matched
    (20) statement -> . statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 175
    statement_unmatched            shift and go to state 126
    statement                      shift and go to state 176
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 167

    (24) statement_matched -> While LParen expression RParen . statement_matched
    (25) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 177
    statement_unmatched            shift and go to state 178
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 168

    (26) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (28) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 179
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 169

    (27) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 180
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 170

    (30) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (48) expression -> . assignment
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 181
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 171

    (24) statement_matched -> While LParen expression . RParen statement_matched

    RParen          shift and go to state 182


state 172

    (21) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched

    RParen          shift and go to state 183


state 173

    (26) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 184


state 174

    (27) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 185


state 175

    (21) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (22) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (19) statement -> statement_matched .

    Else            shift and go to state 186
    RBrace          reduce using rule 19 (statement -> statement_matched .)
    If              reduce using rule 19 (statement -> statement_matched .)
    While           reduce using rule 19 (statement -> statement_matched .)
    For             reduce using rule 19 (statement -> statement_matched .)
    Do              reduce using rule 19 (statement -> statement_matched .)
    Return          reduce using rule 19 (statement -> statement_matched .)
    LBrace          reduce using rule 19 (statement -> statement_matched .)
    Break           reduce using rule 19 (statement -> statement_matched .)
    Continue        reduce using rule 19 (statement -> statement_matched .)
    Int             reduce using rule 19 (statement -> statement_matched .)
    Minus           reduce using rule 19 (statement -> statement_matched .)
    BitNot          reduce using rule 19 (statement -> statement_matched .)
    Not             reduce using rule 19 (statement -> statement_matched .)
    Identifier      reduce using rule 19 (statement -> statement_matched .)
    Integer         reduce using rule 19 (statement -> statement_matched .)
    LParen          reduce using rule 19 (statement -> statement_matched .)
    Semi            reduce using rule 19 (statement -> statement_matched .)


state 176

    (23) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement .)


state 177

    (24) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 24 (statement_matched -> While LParen expression RParen statement_matched .)


state 178

    (25) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 25 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 179

    (26) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched
    (28) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 187


state 180

    (27) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 188


state 181

    (30) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 189


state 182

    (24) statement_matched -> While LParen expression RParen . statement_matched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 177
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 183

    (21) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 190
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 184

    (26) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 191
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 185

    (27) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 192
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 186

    (21) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (22) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 193
    statement_unmatched            shift and go to state 194
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 187

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (28) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 195
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 188

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 196
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 189

    (30) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 197


state 190

    (21) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched

    Else            shift and go to state 198


state 191

    (26) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 199


state 192

    (27) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 200


state 193

    (21) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 21 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 194

    (22) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 195

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched
    (28) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 201


state 196

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched
    (29) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 202


state 197

    (30) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 30 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 198

    (21) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    expression                     shift and go to state 127
    statement_matched              shift and go to state 193
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 199

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 203
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 200

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    RParen          reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 204
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 201

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (28) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 131
    statement_matched              shift and go to state 205
    statement_unmatched            shift and go to state 206
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 202

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (29) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (22) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (23) statement_unmatched -> . If LParen expression RParen statement
    (25) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (28) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 128
    While           shift and go to state 129
    For             shift and go to state 130
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 131
    statement_matched              shift and go to state 207
    statement_unmatched            shift and go to state 208
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 203

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 209


state 204

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 210


state 205

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 26 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)


state 206

    (28) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 28 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 207

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 27 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)


state 208

    (29) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 29 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 209

    (26) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 131
    statement_matched              shift and go to state 205
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39

state 210

    (27) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (21) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (24) statement_matched -> . While LParen expression RParen statement_matched
    (26) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (27) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (48) expression -> . assignment
    (1) empty -> .
    (49) assignment -> . conditional
    (70) assignment -> . unary Assign expression
    (50) conditional -> . logical_or
    (87) conditional -> . logical_or Question expression Colon conditional
    (60) unary -> . postfix
    (62) unary -> . Minus unary
    (63) unary -> . BitNot unary
    (64) unary -> . Not unary
    (51) logical_or -> . logical_and
    (71) logical_or -> . logical_or Or logical_and
    (61) postfix -> . primary
    (65) postfix -> . Identifier LParen expression_list RParen
    (66) postfix -> . postfix LBracket expression RBracket
    (52) logical_and -> . bit_or
    (72) logical_and -> . logical_and And bit_or
    (88) primary -> . Integer
    (89) primary -> . Identifier
    (90) primary -> . LParen expression RParen
    (53) bit_or -> . xor
    (73) bit_or -> . bit_or BitOr xor
    (54) xor -> . bit_and
    (74) xor -> . xor Xor bit_and
    (55) bit_and -> . equality
    (75) bit_and -> . bit_and BitAnd equality
    (56) equality -> . relational
    (76) equality -> . equality NotEqual relational
    (77) equality -> . equality Equal relational
    (57) relational -> . additive
    (78) relational -> . relational Less additive
    (79) relational -> . relational Greater additive
    (80) relational -> . relational LessEqual additive
    (81) relational -> . relational GreaterEqual additive
    (58) additive -> . multiplicative
    (82) additive -> . additive Plus multiplicative
    (83) additive -> . additive Minus multiplicative
    (59) multiplicative -> . unary
    (84) multiplicative -> . multiplicative Mul unary
    (85) multiplicative -> . multiplicative Div unary
    (86) multiplicative -> . multiplicative Mod unary

    If              shift and go to state 151
    While           shift and go to state 150
    For             shift and go to state 152
    Do              shift and go to state 132
    Return          shift and go to state 133
    LBrace          shift and go to state 120
    Break           shift and go to state 134
    Continue        shift and go to state 135
    Semi            reduce using rule 1 (empty -> .)
    Minus           shift and go to state 26
    BitNot          shift and go to state 27
    Not             shift and go to state 28
    Identifier      shift and go to state 19
    Integer         shift and go to state 33
    LParen          shift and go to state 31

    opt_expression                 shift and go to state 131
    statement_matched              shift and go to state 207
    expression                     shift and go to state 127
    empty                          shift and go to state 136
    assignment                     shift and go to state 21
    conditional                    shift and go to state 22
    unary                          shift and go to state 23
    logical_or                     shift and go to state 24
    postfix                        shift and go to state 25
    logical_and                    shift and go to state 29
    primary                        shift and go to state 30
    bit_or                         shift and go to state 32
    xor                            shift and go to state 34
    bit_and                        shift and go to state 35
    equality                       shift and go to state 36
    relational                     shift and go to state 37
    additive                       shift and go to state 38
    multiplicative                 shift and go to state 39
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBracket in state 41 resolved as shift
WARNING: shift/reduce conflict for LBracket in state 110 resolved as shift
